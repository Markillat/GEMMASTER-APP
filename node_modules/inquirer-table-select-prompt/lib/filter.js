"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilterPage = void 0;
const figures = require("figures");
const cloneDeep = require("lodash.clonedeep");
const merge = require("lodash.merge");
const common_1 = require("./utils/common");
const paginator_1 = __importDefault(require("./utils/paginator"));
const terminalSize = require("term-size");
const pc = require("picocolors");
const assert = require("assert");
class FilterPage {
    constructor(rl, screen, events, opt) {
        this.rl = rl;
        this.screen = screen;
        this.events = events;
        this.opt = opt;
        this.isToggledHelp = false;
        this.selectedList = [];
        this.shownList = [];
        this.opt = Object.assign({ pageSize: 15, multiple: false }, this.opt);
        this.paginator = new paginator_1.default(this.screen, { isInfinite: this.opt.loop !== false });
    }
    onKeypress(event) {
        const keyName = (event.key && event.key.name) || undefined;
        if (keyName === 'h' || event.key.sequence === '?' || event.key.sequence === 'ï¼Ÿ') {
            this.isToggledHelp = !this.isToggledHelp;
            this.render();
        }
        else if (keyName === 'down' || (keyName === 'n' && event.key.ctrl)) {
            this.moveActive(1);
        }
        else if (keyName === 'up' || (keyName === 'p' && event.key.ctrl)) {
            this.moveActive(-1);
        }
        else if (keyName === 'left') {
            this.onLeftKey();
        }
        else if (keyName === 'right') {
            this.onRightKey();
        }
        else if (keyName === 'tab') {
            if (this.active.open) {
                this.onLeftKey();
            }
            else {
                this.onRightKey();
            }
        }
        else if (keyName === 'space') {
            this.toggleSelection();
        }
        else if (keyName === 'backspace') {
            this.tree
                .children.filter(({ _isRoot }) => _isRoot)
                .forEach((rootNode) => {
                rootNode._selectedNode = [];
            });
            this.render();
        }
    }
    onLeftKey() {
        if (this.active.children && this.active.open) {
            this.active.open = false;
        }
        else {
            if (this.active._parent !== this.tree) {
                this.active = this.active._parent;
            }
        }
        this.render();
    }
    onRightKey() {
        if (this.active.children) {
            if (!this.active.open) {
                this.active.open = true;
                prepareChildren(this.active).then(() => this.render());
            }
            else if (this.active.children.length) {
                this.moveActive(1);
            }
        }
    }
    async _run(done) {
        this.done = done;
        const tree = {
            children: typeof this.opt.tree === 'function' ? this.opt.tree : cloneDeep(this.opt.tree),
        };
        await runChildrenFunctionIfRequired(tree);
        assert.ok(tree.children, new Error('Property `tree` not found children'));
        for (const node of tree.children) {
            node._isRoot = true;
            node._selectedNode = [];
            await prepareChildren(node);
        }
        if (this.opt.filtersDefault) {
            await this.initSelections(tree);
        }
        this.tree = tree;
        this.render();
    }
    subscribe(events = this.events) {
        const subEventsLine = events.line
            .subscribe(this.onSubmit.bind(this));
        const subEventsKeypress = events.keypress
            .subscribe(this.onKeypress.bind(this));
        this.subscriptions = [subEventsLine, subEventsKeypress];
    }
    unsubscribe(subscriptions = this.subscriptions || []) {
        subscriptions === null || subscriptions === void 0 ? void 0 : subscriptions.forEach((sub) => sub.unsubscribe());
    }
    onSubmit(_line) {
        const res = {};
        this.tree.children.forEach((rootNode) => {
            var _a;
            if ((_a = rootNode._selectedNode) === null || _a === void 0 ? void 0 : _a.length) {
                merge(res, recursiveKeyify(rootNode._selectedNode));
            }
        });
        this.done(res);
    }
    render() {
        let message = this.opt.message;
        this.shownList = [];
        let treeContent = this.createTreeContent();
        message += '\n' + this.paginator.paginate(treeContent, this.shownList.indexOf(this.active), this.opt.pageSize);
        message += '\n' + '  ' + this.renderHelpText();
        this.screen.render(message, '');
    }
    createTreeContent(node = this.tree, indent = 0) {
        const children = node.children || [];
        let output = '';
        children.forEach((child) => {
            this.shownList.push(child);
            if (!this.active)
                this.active = child;
            const { open: isOpen, _isRoot: isRoot, _selectedNode } = child;
            let prefix = child.children
                ? isOpen
                    ? figures.arrowDown + ' '
                    : figures.arrowRight + ' '
                : child === this.active
                    ? figures.pointer + ' '
                    : '  ';
            let suffix = ' ';
            if (isRoot) {
                if (_selectedNode === null || _selectedNode === void 0 ? void 0 : _selectedNode.length)
                    suffix += pc.cyan(_selectedNode.map((item) => shortFor(item)).join(', '));
                prefix += `${pc.green('?')} `;
            }
            else {
                const rootNode = recursiveFindRootNode(child);
                prefix += rootNode._selectedNode.includes(child) ? figures.radioOn : figures.radioOff;
                prefix += ' ';
            }
            const nameForChild = isRoot === true ? pc.bold(nameFor(child)) : nameFor(child);
            const showValue = ' '.repeat(indent) + prefix + nameForChild + suffix + '\n';
            if (child === this.active) {
                if (isRoot !== true) {
                    output += pc.cyan(showValue);
                }
                else {
                    output += showValue;
                }
            }
            else {
                if (isRoot !== true) {
                    output += showValue;
                }
                else {
                    output += pc.gray(showValue);
                }
            }
            if (isOpen) {
                output += this.createTreeContent(child, indent + 2);
            }
        });
        return output;
    }
    moveActive(distance = 0) {
        const currentIndex = this.shownList.indexOf(this.active);
        let index = currentIndex + distance;
        if (index >= this.shownList.length) {
            if (this.opt.loop === false) {
                return;
            }
            index = 0;
        }
        else if (index < 0) {
            if (this.opt.loop === false) {
                return;
            }
            index = this.shownList.length - 1;
        }
        this.active = this.shownList[index];
        this.render();
    }
    toggleSelection() {
        if (this.active._isRoot) {
            this.toggleOpen();
        }
        else {
            const rootNode = recursiveFindRootNode(this.active);
            const selectedIndex = rootNode._selectedNode.indexOf(this.active);
            if (this.opt.multiple) {
                if (selectedIndex === -1) {
                    rootNode._selectedNode.push(this.active);
                }
                else {
                    rootNode._selectedNode.splice(selectedIndex, 1);
                }
            }
            else {
                if (selectedIndex === -1) {
                    rootNode._selectedNode = [this.active];
                }
                else {
                    rootNode._selectedNode = [];
                }
            }
            this.render();
        }
    }
    toggleOpen(enforce) {
        if (!this.active.children) {
            return;
        }
        this.active.open = enforce || !this.active.open;
        this.render();
    }
    renderHelpText(isToggledHelp = this.isToggledHelp) {
        const keyMap = [
            { key: 'esc', desc: 'exit' },
            { key: 'tab', desc: 'toggle' },
            { key: 'space', desc: 'select' },
            { key: 'enter', desc: 'confirm' },
            { key: 'backspace', desc: 'clear' },
        ];
        const hideKeyMap = [];
        return (0, common_1.generateHelpText)({ keyMap, isToggledHelp, hideKeyMap, width: terminalSize().columns });
    }
    async initSelections(node = this.tree, def = this.opt.filtersDefault, _defPath = '') {
        var _a, _b, _c;
        const processedChildren = ((_a = node === null || node === void 0 ? void 0 : node.children) === null || _a === void 0 ? void 0 : _a.reduce((prev, child) => {
            prev[child.key] = child;
            return prev;
        }, {})) || {};
        for (const key in def) {
            const defPath = _defPath + (_defPath ? `.${key}` : key);
            if (key in processedChildren) {
                if (typeof def[key] === 'object') {
                    if (Array.isArray((_b = processedChildren[key]) === null || _b === void 0 ? void 0 : _b.children)) {
                        processedChildren[key].open = true;
                        await prepareChildren(processedChildren[key]);
                        await this.initSelections(processedChildren[key], def[key], defPath);
                    }
                    else {
                        throw new Error(`Property \`tree\` key \`${defPath}\` not found children nodes`);
                    }
                }
                else {
                    processedChildren[key].open = true;
                    await prepareChildren(processedChildren[key]);
                    if (Array.isArray((_c = processedChildren[key]) === null || _c === void 0 ? void 0 : _c.children)) {
                        const selectedChild = processedChildren[key].children.find((child) => valueFor(child) == def[key]);
                        if (selectedChild) {
                            const rootNode = recursiveFindRootNode(processedChildren[key]);
                            if (processedChildren[key])
                                rootNode._selectedNode.push(selectedChild);
                        }
                        else {
                            throw new Error(`Property \`tree\` key \`${defPath}\` children not found value ${pc.green(def[key])}, ${require('util').inspect(processedChildren[key].children)}`);
                        }
                    }
                    else {
                        throw new Error(`Property \`tree\` key \`${defPath}\` not found children nodes`);
                    }
                }
            }
            else {
                continue;
            }
        }
    }
}
exports.FilterPage = FilterPage;
const runChildrenFunctionIfRequired = async (node) => {
    if (typeof node.children === 'function') {
        try {
            const nodeOrChildren = await node.children();
            if (nodeOrChildren) {
                let children;
                if (Array.isArray(nodeOrChildren)) {
                    children = nodeOrChildren;
                }
                else {
                    children = nodeOrChildren.children;
                    ['name', 'value', 'short'].forEach((property) => {
                        node[property] = nodeOrChildren[property];
                    });
                }
                node.children = cloneDeep(children);
            }
        }
        catch (e) {
            node.children = null;
        }
    }
};
const prepareChildren = async (node) => {
    if (node._prepared)
        return;
    node._prepared = true;
    await runChildrenFunctionIfRequired(node);
    if (!node.children)
        return;
    node.children = node.children.map((item) => {
        if (typeof item !== 'object')
            return { value: item };
        return item;
    });
    await validateAndFilterDescendants(node);
};
const validateAndFilterDescendants = async (node) => {
    for (let index = node.children.length - 1; index >= 0; index--) {
        const child = node.children[index];
        child._parent = node;
        if (child.open) {
            await prepareChildren(child);
        }
    }
};
const shortFor = (node) => {
    return typeof node.short !== 'undefined' ? node.short : nameFor(node);
};
const nameFor = (node) => {
    if (typeof node.name !== 'undefined') {
        return node.name;
    }
    return node.value.toString();
};
const valueFor = (node) => {
    return typeof node.value !== 'undefined' ? node.value : node.name;
};
const recursiveFindRootNode = (node) => {
    let side = node;
    if (side._root)
        return side._root;
    while (side && !side._isRoot) {
        side = side._parent;
    }
    node._root = side;
    return side;
};
const recursiveKeyify = (nodes) => {
    const res = {};
    for (const node of nodes) {
        let val = valueFor(node);
        let side = node;
        do {
            side = side._parent;
            val = { [side.key]: val };
        } while (side && !side._isRoot);
        merge(res, val);
    }
    return res;
};
//# sourceMappingURL=filter.js.map