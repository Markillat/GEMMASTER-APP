"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TableSelectPrompt = void 0;
const cli_spinners_1 = require("cli-spinners");
const debug_1 = __importDefault(require("debug"));
const memoize_one_1 = __importDefault(require("memoize-one"));
const operators_1 = require("rxjs/operators");
const filter_1 = require("./filter");
const types_1 = require("./types");
const common_1 = require("./utils/common");
const observe_1 = require("./utils/observe");
const paginator_1 = require("./utils/paginator");
const Table = require("easy-table");
const figures = require("figures");
const isPlainObject = require("lodash.isplainobject");
const terminalSize = require("term-size");
const pc = require("picocolors");
const Base = require("inquirer/lib/prompts/base");
const observe = require("inquirer/lib/utils/events");
const utils = require("inquirer/lib/utils/readline");
const assert = require("assert");
const cliCursor = require("cli-cursor");
const merge = require("lodash.merge");
const debug = (0, debug_1.default)('inquirer-table-select:index');
class TableSelectPrompt extends Base {
    constructor(question, rl, answers) {
        super(question, rl, answers);
        this.pageSize = this.opt.pageSize || 15;
        this.paginator = new paginator_1.Paginator(this.screen, {
            isInfinite: this.opt.loop === undefined ? true : this.opt.loop,
            isShowHelp: false,
        });
        this._ui = {
            isLoading: true,
            isToggledHelp: false,
            selectedIndex: 0,
            currentTabIndex: 0,
        };
        this.status = types_1.Status.Pending;
        this.isFiltersFirstRender = false;
        this.context = { filters: {}, data: [] };
        this.router = types_1.Router.NORMAL;
        this._portal = {};
        this.createSpinner = async (func) => {
            const screen = this.screen;
            const message = this.getQuestion().replace(`${pc.green('?')} `, '');
            const loadingText = this.opt.loadingText || 'Loading...';
            let spinnerIndex = 0;
            const spinner = setInterval(() => {
                spinnerIndex++;
                if (spinnerIndex >= cli_spinners_1.arc.frames.length) {
                    spinnerIndex = 0;
                }
                const spinnerFrame = cli_spinners_1.arc.frames[spinnerIndex];
                screen.render(`${pc.blue(spinnerFrame)} ${message}
  ${pc.dim(loadingText)}`, '');
            }, cli_spinners_1.arc.interval);
            await func();
            clearInterval(spinner);
            return spinner;
        };
        const { data, source, tab, filtersDefault } = this.opt;
        this.opt.default = null;
        assert.ok(data || source, new Error('Your muse provide `data` or `source` parameter'));
        if (!source && ['tree', 'loadingText'].some((v) => v in this.opt))
            this.throwParamError('source');
        if (tab)
            this.initTab();
        if (filtersDefault)
            merge(this.context, { filters: filtersDefault });
    }
    getTabValue(index = this._ui.currentTabIndex) {
        const curr = this.tabChoiceList[index];
        if (typeof curr === 'object')
            return typeof curr.value !== 'undefined' ? curr.value : curr.name;
        else if (typeof curr !== 'undefined')
            return curr;
        return null;
    }
    get currentRow() {
        return this.context.data[this.ui.selectedIndex];
    }
    initTab(tab = this.opt.tab) {
        const { children, key } = tab;
        this.tabChoiceKey = key;
        assert.ok(Array.isArray(children) && children.every((i) => typeof i === 'object'), new Error('Property `tab.children` cannot contain object items'));
        this.tabChoiceList = children;
        if (tab.default || (this.opt.filtersDefault && key in this.opt.filtersDefault)) {
            const currentTabIndex = children.findIndex((child) => {
                const v = tab.default || this.opt.filtersDefault[key];
                if (typeof child === 'object')
                    return (typeof child.value !== 'undefined' ? child.value : child.name) === v;
                else
                    return child === v;
            });
            assert.ok(currentTabIndex !== -1, 'Property `tab.children` must contain the value you set in property `tab.default` or property `filtersDefault`');
            this._ui.currentTabIndex = currentTabIndex;
        }
        this.context.filters[key] = this.getTabValue();
    }
    async _run(cb) {
        this.done = cb;
        cliCursor.hide();
        const [observedObject, observedObjectChange$] = (0, observe_1.observeObject)(this._ui);
        this.ui = observedObject;
        this.observedObjectChange$ = observedObjectChange$;
        await this.createSpinner(async () => {
            await this.fetchData();
        });
        debug('_run');
        this.renderNormal();
        const events = observe(this.rl);
        this.events = events;
        this.subscribe();
        return this;
    }
    subscribe(events = this.events) {
        const dontHaveAnswer = () => this.answer === undefined;
        const filterLoadings = () => this.ui.isLoading === false;
        const subObjectChange = this.observedObjectChange$
            .pipe((0, operators_1.takeWhile)(dontHaveAnswer), (0, operators_1.filter)(filterLoadings))
            .subscribe((changes) => {
            debug(changes);
            this.renderNormal();
        });
        const subEventsLine = events.line
            .pipe((0, operators_1.takeWhile)(dontHaveAnswer), (0, operators_1.filter)(filterLoadings))
            .subscribe(this.onSubmit.bind(this));
        const subEventsKeypress = events.keypress
            .pipe((0, operators_1.takeWhile)(dontHaveAnswer), (0, operators_1.filter)(filterLoadings))
            .subscribe(this.onKeypress.bind(this));
        this.subscriptions = [subObjectChange, subEventsLine, subEventsKeypress];
    }
    unsubscribe(subscriptions = this.subscriptions || []) {
        subscriptions === null || subscriptions === void 0 ? void 0 : subscriptions.forEach((sub) => sub.unsubscribe());
    }
    onKeypress(event) {
        var _a, _b, _c;
        const keyName = ((_a = event === null || event === void 0 ? void 0 : event.key) === null || _a === void 0 ? void 0 : _a.name) || undefined;
        if (event.key.name === 'q')
            process.exit(0);
        if (keyName === 'h' || event.key.sequence === '?' || event.key.sequence === '？') {
            this.onHelpKey();
        }
        else if (keyName === 'down' || (keyName === 'n' && event.key.ctrl)) {
            this.onDownKey();
        }
        else if (keyName === 'up' || (keyName === 'p' && event.key.ctrl)) {
            this.onUpKey();
        }
        else if (keyName === 'left') {
            if (((_b = this.context.pagination) === null || _b === void 0 ? void 0 : _b.hasPreviousPage) && this.opt.prev)
                this.onLeftKey();
        }
        else if (keyName === 'right') {
            if (((_c = this.context.pagination) === null || _c === void 0 ? void 0 : _c.hasNextPage) && this.opt.next)
                this.onRightKey();
        }
        else if (event.key.sequence === '/' || keyName === 'f') {
            if (this.opt.tree)
                this.onSlashKey();
        }
        else if (keyName === 'tab') {
            if (this.opt.tab)
                this.onTabKey();
        }
    }
    onHelpKey() {
        this.ui.isToggledHelp = !this.ui.isToggledHelp;
    }
    onDownKey() {
        let index = this.ui.selectedIndex;
        do {
            index = index < this.context.data.length - 1 ? index + 1 : 0;
        } while (!isRowSelectable(this.context.data[index]));
        this.ui.selectedIndex = index;
        utils.up(this.rl, 2);
    }
    onUpKey() {
        let index = this.ui.selectedIndex;
        do {
            index = index > 0 ? index - 1 : this.context.data.length - 1;
        } while (!isRowSelectable(this.context.data[index]));
        this.ui.selectedIndex = index;
    }
    onLeftKey() {
        var _a, _b;
        const payload = merge({}, this.context);
        const patch = ((_b = (_a = this.opt).prev) === null || _b === void 0 ? void 0 : _b.call(_a, payload)) || {};
        merge(payload, patch);
        this.createSpinner(async () => {
            await this.fetchData(payload).then(() => {
                this.context = payload;
                this.renderNormal();
            });
        });
    }
    onRightKey() {
        var _a, _b;
        const payload = merge({}, this.context);
        const patch = ((_b = (_a = this.opt).next) === null || _b === void 0 ? void 0 : _b.call(_a, payload)) || {};
        merge(payload, patch);
        this.createSpinner(async () => {
            await this.fetchData(payload).then(() => {
                this.context = payload;
                this.renderNormal();
            });
        });
    }
    onSlashKey() {
        this.router = types_1.Router.FILTER;
        this.unsubscribe();
        this.createSpinner(async () => {
            const filterPage = new filter_1.FilterPage(this.rl, this.screen, this.events, {
                tree: this.opt.tree,
                message: `${this.getQuestion()}
  ${pc.gray('Filters:')}
`,
                filtersDefault: this.isFiltersFirstRender ? this.context.filters : this.opt.filtersDefault,
            });
            filterPage.subscribe();
            await filterPage._run(async (options) => {
                this.router = types_1.Router.NORMAL;
                filterPage.unsubscribe();
                if (typeof options === 'object') {
                    await this.createSpinner(async () => {
                        const base = this.opt.tab ? { [this.tabChoiceKey]: this.getTabValue() } : {};
                        const payload = merge({}, this.context, { filters: Object.assign(Object.assign({}, base), options) });
                        await this.createSpinner(async () => {
                            await this.fetchData(payload);
                        });
                        this.context = payload;
                        if (this.opt.tab) {
                            this.updateTabState();
                        }
                    });
                }
                this.renderNormal();
                this.subscribe();
            });
            this.isFiltersFirstRender = true;
        });
    }
    onTabKey() {
        var _a;
        if ((_a = this.tabChoiceList) === null || _a === void 0 ? void 0 : _a.length) {
            this.context.pagination = {};
            const nextIndex = (this.ui.currentTabIndex + 1) % this.tabChoiceList.length;
            const payload = merge({}, this.context, { filters: { [this.tabChoiceKey]: this.getTabValue(nextIndex) } });
            this.createSpinner(async () => {
                await this.fetchData(payload);
                this.context = payload;
                this.ui.currentTabIndex = nextIndex;
            });
        }
    }
    onSubmit(_line) {
        var _a, _b;
        this.status = types_1.Status.Done;
        this.answer = (_a = (this.currentRow.short || this.currentRow.name || this.currentRow.value)) !== null && _a !== void 0 ? _a : this.currentRow.row;
        this.screen.render(`${this.getQuestion()}${pc.cyan(this.answer)}`, '');
        this.screen.done();
        cliCursor.show();
        this.done((_b = this.currentRow.value) !== null && _b !== void 0 ? _b : this.currentRow.row);
    }
    updateTabState() {
        const newTabValue = this.context.filters[this.tabChoiceKey];
        let newTabIndex = this._ui.currentTabIndex, flag = 0;
        for (const tab of this.tabChoiceList) {
            if (typeof tab === 'object') {
                const val = typeof tab.value !== 'undefined' ? tab.value : tab.name;
                if (val === newTabValue) {
                    newTabIndex = flag;
                    this.ui.currentTabIndex = newTabIndex;
                    return;
                }
            }
            else if (typeof tab !== 'undefined') {
                if (tab === newTabValue) {
                    newTabIndex = flag;
                    this.ui.currentTabIndex = newTabIndex;
                    return;
                }
            }
            ++flag;
        }
    }
    async fetchData(payload = this.context || {}) {
        if (this.opt.source) {
            debug('renderData::source');
            this.ui.selectedIndex = 0;
            this.ui.isLoading = true;
            await this.request(payload);
            const selectedIndex = payload.data.findIndex((v) => { var _a; return v.value === ((_a = this.opt) === null || _a === void 0 ? void 0 : _a.default); });
            this.ui.selectedIndex = selectedIndex !== -1 ? selectedIndex : 0;
            this.ui.isLoading = false;
        }
        else if (this.opt.data) {
            debug('fetchData start');
            this.ui.isLoading = true;
            payload.data = validateData(this.opt.data);
            const selectedIndex = payload.data.findIndex((row) => { var _a; return row.value === ((_a = this.opt) === null || _a === void 0 ? void 0 : _a.default); });
            this.ui.selectedIndex = selectedIndex !== -1 ? selectedIndex : 0;
            this.ui.isLoading = false;
            debug('fetchData end');
        }
    }
    async request(payload = this.context || {}) {
        let thisPromise;
        try {
            const result = this.opt.source(this.answers, payload);
            thisPromise = Promise.resolve(result);
        }
        catch (error) {
            thisPromise = Promise.reject(error);
        }
        const lastPromise = thisPromise;
        const patch = await thisPromise;
        assert.ok(isPlainObject(patch), new Error('`Source` method must return a plain object'));
        const { data, pagination: newPagination } = patch, rest = __rest(patch, ["data", "pagination"]);
        assert.ok(Array.isArray(data), new Error(`\`Source\` method must return ${pc.green('{ data: Row[] }')}`));
        if (thisPromise !== lastPromise)
            return;
        payload.data = validateData(data);
        payload.pagination = newPagination || {};
        merge(payload, rest);
    }
    renderNormal(error) {
        var _a, _b;
        debug('render');
        let content = this.getQuestion();
        let lines = [];
        let bottomLines = [];
        if (error) {
            lines = [`${pc.red('>> ')}${error}`];
            return this.screen.render(content, lines.join('\n'));
        }
        if ((_a = this.tabChoiceList) === null || _a === void 0 ? void 0 : _a.length)
            lines.push(renderTab(this.tabChoiceList, this.ui.currentTabIndex));
        if ((_b = this.context.data) === null || _b === void 0 ? void 0 : _b.length) {
            const { head, body } = renderTable(this.context.data, this.ui.selectedIndex);
            lines.push(pc.bgWhite(pc.bold(head[0])));
            const len = head[1].length;
            if (this.ui.isLoading)
                lines.push('  ' + pc.dim(this.opt.loadingText || 'Loading...'));
            else {
                lines.push(this.paginator.paginate(body, this.ui.selectedIndex, this.pageSize));
                bottomLines.push(this.renderIndicator(len));
            }
            bottomLines.push(renderLine(len));
            this._portal.len = len;
            this._portal.head = pc.bgWhite(pc.bold(head[0]));
        }
        else {
            if (this._portal.head)
                lines.push(this._portal.head);
            if (this.ui.isLoading)
                lines.push('  ' + pc.dim(this.opt.loadingText || 'Loading...'));
            else {
                lines.push('  ' + pc.yellow(this.opt.emptyText || 'No results...'));
            }
            if (this._portal.len) {
                bottomLines.push(this.renderIndicator(this._portal.len));
                bottomLines.push(renderLine(this._portal.len));
            }
        }
        bottomLines.push('  ' + this.renderHelpText());
        lines.push(...bottomLines);
        this.screen.render(content, lines.join('\n'));
    }
    renderIndicator(limitSize) {
        var _a;
        let left = '';
        if ((_a = this.context.data) === null || _a === void 0 ? void 0 : _a.length)
            left += '  ' + `Select ${this.ui.selectedIndex + 1}/${this.context.data.length}`;
        let right = '';
        if (this.context.pagination) {
            const { currentPage, totalPages, hasNextPage, hasPreviousPage } = this.context.pagination;
            if (typeof currentPage === 'number' && typeof totalPages === 'number')
                left += common_1.SEPERATOR_CHAR + `Page ${this.context.pagination.currentPage}/${this.context.pagination.totalPages}`;
            const rightChunk = [];
            hasPreviousPage && rightChunk.push(`← prev`);
            hasNextPage && rightChunk.push(`next →`);
            if (rightChunk.length) {
                right = rightChunk.join(common_1.SEPERATOR_CHAR);
                const spaceLen = limitSize - left.length - 2;
                if (spaceLen > common_1.SEPERATOR_CHAR.length) {
                    right = right.padStart(spaceLen, ' ').replace(right, rightChunk.map(pc.bold).join(common_1.SEPERATOR_CHAR));
                }
                else {
                    right = pc.white(common_1.SEPERATOR_CHAR) + right;
                }
            }
        }
        return '\n' + pc.dim(left) + pc.gray(right);
    }
    renderHelpText(isToggledHelp = this.ui.isToggledHelp) {
        const hideKeyMap = [
            { key: 'q', desc: 'quit' },
            { key: `enter`, desc: 'submit' },
        ];
        const keyMap = [];
        if (this.context.pagination)
            keyMap.push({ key: `↔`, desc: 'turn pages' });
        if (this.opt.tree)
            keyMap.push({ key: `/`, desc: 'filters' });
        if (this.opt.tab)
            keyMap.push({ key: `tab`, desc: 'switch tabs' });
        return (0, common_1.generateHelpText)({ keyMap, isToggledHelp, hideKeyMap, width: terminalSize().columns });
    }
}
exports.TableSelectPrompt = TableSelectPrompt;
const renderTab = (0, memoize_one_1.default)((tabs, activeIndex) => {
    const seperator = '|';
    const res = tabs
        .map((choice, index) => {
        const tabName = choice.short || choice.name || choice.value;
        return activeIndex === index ? pc.bgCyan(` ${tabName} `) : ` ${tabName} `;
    })
        .join(seperator);
    return `  ${pc.dim('Tab:')} ${res}`;
});
const renderTable = (0, memoize_one_1.default)((rowCollections, pointer) => {
    const text = Table.print(rowCollections, (item, cell) => {
        const entries = Object.entries(item.row);
        entries.forEach(([key, value], index) => {
            if (index === entries.length - 1)
                return cell(`${key}  `, value);
            return cell(key, value);
        });
    }, (table) => {
        return table.toString().replace(/\n$/, '');
    }).split('\n');
    const res = {
        head: text.slice(0, 2).map((str) => `  ${str}`),
        body: text
            .slice(2)
            .map((rowStr, i) => {
            if (!isRowSelectable(rowCollections[i])) {
                return `  ${pc.dim(rowStr)}`;
            }
            const isSelected = i === pointer;
            return isSelected ? `${pc.cyan(figures.pointer)} ${pc.cyan(rowStr)}` : `  ${rowStr}`;
        })
            .join('\n'),
    };
    return res;
});
const renderLine = (0, memoize_one_1.default)((strokeSize) => {
    return `${'┈'.repeat(strokeSize)}`;
});
const isRowSelectable = (row) => {
    return row && !row.disabled;
};
const validateData = (collection) => {
    assert.ok(collection.every((row) => row.row), 'Every data item must have a `row` property');
    return collection;
};
//# sourceMappingURL=index.js.map